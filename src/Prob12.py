"""
PROJECT EULER
Problem 12

The sequence of triangle numbers is generated by
adding the natural numbers. So the 7th triangle number
would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.

The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?


Author: Adam Beagle
"""

from math import sqrt
from Timer import Timer
from EulerUtility import GetPrimeFactorization, SieveOfEratosthenes

################################################################################
def Counts(lst):
    """
    Returns list of 2-tuples of elements, and how many times they appear in lst.
    Example: Input [3, 3, 2, 2, 2, 4] Output [(2, 3), (3, 2), (4, 1)]
    """
    counts = []
    
    unique = list(set(lst))

    for el in unique:
        counts.append((el, lst.count(el)))

    return sorted(counts)
    
#-----------------------------------------------------------------------------
def GetNumDivisors(n, primes):
    """
    Returns number of divisor in n.
    Primes is list of primes in increasing order.
    """
    #With n = a^x, b^y, c^z, ...
    #where a, b, c, etc. are prime and x, y, z, etc. are > 0,
    #num divisors in n = (x + 1)*(y + 1)*(z + 1)*...
    primeFactors = GetPrimeFactorization(n, primes)

    if not primeFactors:
        print "WARNING: Prime factorization for %d could not be determined.\nA longer 'primes' is required (Current maximum %d).\n" % (n, primes[-1])
    
    exponentialForm = Counts(primeFactors)
    numDivisors = 1

    for factor in exponentialForm:
        numDivisors *= (factor[1] + 1)

    return numDivisors


#-----------------------------------------------------------------------------
def GetTriNum(n):
    """Returns the nth triangle number."""
    return (n*(n + 1)) / 2

#-----------------------------------------------------------------------------
def Prob12():
    n = 1            #Represents which triangle number is current (i.e. 1 for '1st', 10 for '10th')
    triNum = 1
    _min = 14414400  #First highly-composite number to have over 500 divisors, thus answer cannot be lower.
                     #From http://wwwhomes.uni-bielefeld.de/achim/highly.txt

    #Generate reasonable amount of primes
    #Limit is fairly arbitrary. Warnings will be printed in GetNumDivisors if limit is insufficient.
    primes = SieveOfEratosthenes(10*int(sqrt(_min)))
                          
    #Find first triangle number >= _min
    while triNum <= _min:
        n += 1
        triNum = GetTriNum(n)

    #Keep generating triangle numbers until one has # divisors > 500
    while GetNumDivisors(triNum, primes) <= 500:
        n += 1
        triNum = GetTriNum(n)

        #Answer is essentially guaranteed to have at least 2, 3, and 5
        #as factors, so skip any numbers that do not.
        while not (triNum % 2 == 0 and triNum % 3 == 0 and triNum % 5 == 0):
            n += 1
            triNum = GetTriNum(n)

    return triNum


################################################################################
if __name__ == '__main__':
    try:
        with Timer() as timer:
            print 'Answer: ' + str(Prob12())
    finally:
        print 'Time: %.5fs' % timer.Interval
