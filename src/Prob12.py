"""
PROJECT EULER
Problem 12

The sequence of triangle numbers is generated by
adding the natural numbers. So the 7th triangle number
would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.

The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28

We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?


Author: Adam Beagle
"""

from math import sqrt
from Timer import Timer

################################################################################
def Counts(lst):
    """
    Returns list of 2-tuples of elements, and how many times they appear in lst.
    Example: Input [3, 3, 2, 2, 2, 4] Output [(2, 3), (3, 2), (4, 1)]
    """
    counts = []
    
    unique = list(set(lst))

    for el in unique:
        counts.append((el, lst.count(el)))

    return sorted(counts)
    
#-----------------------------------------------------------------------------
def GetNumDivisors(n, primes):
    """
    Returns number of divisor in n.
    Primes is list of primes in increasing order.
    """
    #With n = a^x, b^y, c^z, ...
    #where a, b, c, etc. are prime and x, y, z, etc. are > 0,
    #num divisors in n = (x + 1)*(y + 1)*(z + 1)*...
    primeFactors = GetPrimeFactorization(n, primes)
    exponentialForm = Counts(primeFactors)
    numDivisors = 1

    for factor in exponentialForm:
        numDivisors *= (factor[1] + 1)

    return numDivisors

#-----------------------------------------------------------------------------
def GetPrimeFactorization(n, primes):
    """
    Returns a list of 2-tuples representing the prime factorization of n,
    or an empty list if factorization not successful.
    Tuples are of form (prime, exponent)
    Factorization will only fail if a prime factor of n is larger
    than the largest value in primes.
    Primes must be in increasing order.
    """
    factors = []

    if n in primes:
        return [n]
    
    for p in primes:
        if p > (n / 2):
          break
        
        if n % p == 0:
            factors.append(p)
            factors += GetPrimeFactorization(n / p, primes)
            break

    prod = 1
    for f in factors:
        prod *= f

    return factors if prod == n else []

#-----------------------------------------------------------------------------
def GetTriNum(n):
    """Returns the nth triangle number."""
    return (n*(n + 1)) / 2

#-----------------------------------------------------------------------------
def Prob12():
    n = 1            #Represents which triangle number is current (i.e. 1 for '1st', 10 for '10th')
    triNum = 1
    _min = 14414400  #First highly-composite number to have over 500 divisors, thus answer cannot be lower.
                     #From http://wwwhomes.uni-bielefeld.de/achim/highly.txt

    #Generate reasonable amount of primes
    primes = SieveOfEratosthenes(int(sqrt(10*_min)))
                          
    #Find first triangle number >= _min
    while triNum <= _min:
        n += 1
        triNum = GetTriNum(n)

    #Keep generating triangle numbers until one has # divisors > 500
    while GetNumDivisors(triNum, primes) <= 500:
        n += 1
        triNum = GetTriNum(n)

        #Answer is essentially guaranteed to have at least 2, 3, and 5
        #as factors, so skip any numbers that do not.
        while not (triNum % 2 == 0 and triNum % 3 == 0 and triNum % 5 == 0):
            n += 1
            triNum = GetTriNum(n)

    return triNum

#-----------------------------------------------------------------------------
def SieveOfEratosthenes(limit):
    """Returns list of primes <= limit, in increasing order."""
    sieve = [True] * (limit + 1)
    i = 2
    
    while i < sqrt(limit):
        if sieve[i]:
            m = 0
            j = i**2
            while j <= limit:
                sieve[j] = False
                m += 1
                j = (i**2) + (m*i)
                
        i += 1

    return [index for index,value in enumerate(sieve) if index >= 2 and value]

################################################################################
if __name__ == '__main__':
    try:
        with Timer() as timer:
            print 'Answer: ' + str(Prob12())
    finally:
        print 'Time: %.5fs' % timer.Interval
