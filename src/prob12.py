"""
PROJECT EULER
Problem 12

Author: Adam Beagle

PROBLEM DESCRIPTION:
  The sequence of triangle numbers is generated by
  adding the natural numbers. So the 7th triangle number
  would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.

  The first ten terms would be:
  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

  Let us list the factors of the first seven triangle numbers:
   1: 1
   3: 1,3
   6: 1,2,3,6
  10: 1,2,5,10
  15: 1,3,5,15
  21: 1,3,7,21
  28: 1,2,4,7,14,28

  We can see that 28 is the first triangle number to have over five divisors.
  What is the value of the first triangle number to have over five hundred divisors?

"""

from math import sqrt

from timer import Timer
from eulerutility import (get_prime_factorization, sieve_of_eratosthenes,
                          unique_counts)

###############################################################################
def get_num_divisors(n, primes):
    """
    Return number of divisors in n.
    Primes is list of primes in increasing order.
    
    """
    # With n = a^x, b^y, c^z, ...
    # where a, b, c, etc. are prime and x, y, z, etc. are > 0,
    # num divisors in n = (x + 1)*(y + 1)*(z + 1)*...
    primeFactors = get_prime_factorization(n, primes)

    if not primeFactors:
        print ("WARNING: Prime factorization for %d could not be determined." +
               "\nA longer 'primes' is required (Current maximum %d).\n" %
               (n, primes[-1]))
    
    exponentialForm = unique_counts(primeFactors)
    numDivisors = 1

    for factor in exponentialForm:
        numDivisors *= (factor[1] + 1)

    return numDivisors

def get_tri_num(n):
    """Return the nth triangle number."""
    return (n*(n + 1)) / 2

def prob12():
    n = 1            # Represents which triangle number is current
    triNum = 1
    _min = 14414400  # First highly-composite number to have over 500 divisors,
                     # thus answer cannot be lower.
                     # From http://wwwhomes.uni-bielefeld.de/achim/highly.txt

    # Generate reasonable amount of primes
    # Limit is fairly arbitrary. Warnings will be printed in get_num_divisors
    # if limit is insufficient.
    primes = sieve_of_eratosthenes(10*int(sqrt(_min)))
                          
    # Find first triangle number >= _min
    while triNum <= _min:
        n += 1
        triNum = get_tri_num(n)

    # Keep generating triangle numbers until one has # divisors > 500
    while get_num_divisors(triNum, primes) <= 500:
        n += 1
        triNum = get_tri_num(n)

        # Answer is essentially guaranteed to have at least 2, 3, and 5
        # as factors, so skip any numbers that do not.
        while not (triNum % 2 == 0 and triNum % 3 == 0 and triNum % 5 == 0):
            n += 1
            triNum = get_tri_num(n)

    return triNum

###############################################################################
if __name__ == '__main__':
    try:
        with Timer() as timer:
            print 'Answer: ' + str(prob12())
    finally:
        print 'Time:   %.5fs' % timer.interval
